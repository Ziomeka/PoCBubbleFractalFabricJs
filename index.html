<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Fabric.js - Bubles</title>
    <style>
        html, body {width: 100%; height: 100%; margin: 0;}
        .page {position: fixed; top: 0; left: 0; width: 100vw; height: 100vh}
    </style>
</head>

<body>
    <div class="page">
        <canvas id='c'></canvas>
    </div>
    <script src="js/fabric.min.js"></script>
    <script src="js/hammer.min.js"></script>
    <script src="js/data.js"></script>

    <script>
        document.addEventListener('DOMContentLoaded',function(){
            const ACTIVE_CIRCLE_RADIUS = 1000,
            ACTIVE_CIRCLE_OFFSET_X = -900;
            ACTIVE_CIRCLE_TEXT_WIDTH = 400,
            CHILD_CIRCLE_RADIUS = 75
            CHILD_CIRCLE_POSITION_RADIUS = 1150,
            CHILDREN_DISTANCE_IN_ANGLE = 10,
            CHILDREN_START_POSITION_ANGLE = -10,
            GAP_HEIGHT = 50,
            PAGE_HEIGHT_PER_CHILD = 2 * CHILD_CIRCLE_RADIUS + GAP_HEIGHT,
            FONT_SIZE = 20,
            MAX_CHILD_NUMBER = 64;

            const fromSphericToCartesian = (radius, angle, offsetX, offsetY) => {
                let theta = angle * Math.PI / 180;
                return {
                    x: radius * Math.cos(theta) + offsetX,
                    y: radius * Math.sin(theta) + offsetY,
                    angle: angle
                }
            }

            const generateStartPositions = (numberOfPositions, positionRadius, angleStep, angleOffset, offsetX, offsetY) => {
                let positionsArray = [];
                for (i = 0; i < numberOfPositions; i++) {
                    angle = (i * angleStep) + angleOffset;
                    positionsArray.push(fromSphericToCartesian(positionRadius, angle, offsetX, offsetY));
                }
                return positionsArray;
            }

            const childrensStartPositions = generateStartPositions(MAX_CHILD_NUMBER, CHILD_CIRCLE_POSITION_RADIUS, CHILDREN_DISTANCE_IN_ANGLE, CHILDREN_START_POSITION_ANGLE, ACTIVE_CIRCLE_OFFSET_X, 0);

            const width = window.innerWidth,
            height = window.innerHeight;

            let curentElement = 0;

            let canvas = new fabric.Canvas('c', {
                width: width,
                height: height,
                backgroundColor: '#fff',
                allowTouchScrolling: false,
                selection: true,
                controlsAboveOverlay: true,
            });

            const setCurrentElement = (index) => {
                if (index !== curentElement) {
                    curentElement = index;
                } else if (curentElement !== 0){
                    curentElement = data[curentElement].parent;
                } else {
                    curentElement = 0;
                }
            }

            const addActiveElement = (element) => {
                let activeCircle = new fabric.Circle({
                    radius: ACTIVE_CIRCLE_RADIUS,
                    fill: element.color,
                    left: ACTIVE_CIRCLE_OFFSET_X,
                    top: height / 2,
                    originX: 'center',
                    originY: 'center',
                    hasControls: false,
                    hasBorders: false,
                    lockMovementX: true,
                    lockMovementY: true,
                    id: element.id
                });
                canvas.add(activeCircle);
            }

            let childElements = [];
            const addChildElement = (element, index) => {
                let childCircle = new fabric.Circle({
                    radius: CHILD_CIRCLE_RADIUS,
                    fill: element.color,
                    originX: 'center',
                    originY: 'center',
                });
                let childText = new fabric.Text(element.text, {
                    fontSize: FONT_SIZE,
                    textAlign: 'center',
                    originX: 'center',
                    originY: 'center'
                });
                let childElement = new fabric.Group([childCircle, childText], {
                    originX: 'center',
                    originY: 'center',
                    hasControls: false,
                    hasBorders: false,
                    lockMovementX: true,
                    lockMovementY: true,
                    left: childrensStartPositions[index].x,
                    top: height / 2 + childrensStartPositions[index].y,
                    id: element.id
                });
                canvas.add(childElement);
                childElements.push(childElement);
            }

            const setScene = (element) => {
                let pageWidth = `${PAGE_HEIGHT_PER_CHILD * element.children.length + 2 * GAP_HEIGHT}px`
                document.querySelector('body').style.height = pageWidth;
                addActiveElement(element);
                element.children.forEach((child, index) => {
                    addChildElement(data[child], index);
                });
                canvas.renderAll();
            };

            const redraw = () => {
                window.scrollTo(0, 0);
                canvas.clear();
                childElements = [];
                setScene(data[curentElement]);
            }

            let clickAviable = true;
            canvas.on('mouse:up', function(e) {
                if (clickAviable) {
                    setCurrentElement(e.target.id);
                    redraw();
                } else {
                    clickAviable = true;
                }
            });

            let moveOnScroll = () => {
                let scrollPosition = window.scrollY || document.documentElement.scrollTop;
                currentCameraAngle = -scrollPosition / (PAGE_HEIGHT_PER_CHILD / CHILDREN_DISTANCE_IN_ANGLE);
                childElements.forEach((child, index) => {
                    let posiition = fromSphericToCartesian(CHILD_CIRCLE_POSITION_RADIUS, childrensStartPositions[index].angle + currentCameraAngle, ACTIVE_CIRCLE_OFFSET_X, 0);
                    child.left = posiition.x;
                    child.top = height/2 + posiition.y;
                    if (child.top < height) child.scale(1);
                });
                canvas.renderAll();
            }

            let skipCircle = (direction) => {
                if (direction ==='up') {
                    currentCameraAngle = currentCameraAngle - CHILDREN_DISTANCE_IN_ANGLE;
                } else if (direction ==='down') {
                    currentCameraAngle = currentCameraAngle + CHILDREN_DISTANCE_IN_ANGLE;
                };
                childElements.forEach((child, index) => {
                    let posiition = fromSphericToCartesian(CHILD_CIRCLE_POSITION_RADIUS, childrensStartPositions[index].angle + currentCameraAngle, ACTIVE_CIRCLE_OFFSET_X, 0);
                    child.left = posiition.x;
                    child.top = height/2 + posiition.y;
                    if (child.top < height) child.scale(1);
                });
                canvas.renderAll();
            }

            const touchMe = document.querySelector('body');
            let hammertime = new Hammer(touchMe);
            hammertime.get('pan').set({ direction: Hammer.DIRECTION_VERTICAL, threshold: 50 });
            hammertime.on('panend', function(ev) {
                if (ev.deltaY > 0) {
                    skipCircle('down');
                } else if (ev.deltaY < 0) {
                    skipCircle('up');
                };
                clickAviable = false;
            });

            let currentCameraAngle = 0;
            setScene(data[0]);
            // window.addEventListener('scroll', moveOnScroll);
        });
    </script>
</body>

</html>
